---
title: "Appleã®Metalãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’ä½¿ç”¨ã—ãŸãƒ›ãƒ¢ã‚°ãƒ©ãƒ•ã‚£å¤‰æ›ã®å®Ÿè£…"
emoji: "ğŸ–¼ï¸"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["iOS", "Metal", "Graphics", "Shader", "ImageProcessing"]
published: true
---

# ãƒ›ãƒ¢ã‚°ãƒ©ãƒ•ã‚£å¤‰æ›ã®åŸºæœ¬

- **ãƒ›ãƒ¢ã‚°ãƒ©ãƒ•ã‚£(Homography)å¤‰æ›**:
  - å¹³é¢ä¸Šã®ç‚¹ã‚’åˆ¥ã®å¹³é¢ä¸Šã®ç‚¹ã«å¤‰æ›ã™ã‚‹å°„å½±å¤‰æ›ã§ã™ã€‚
  - 3x3ã®ãƒ›ãƒ¢ã‚°ãƒ©ãƒ•ã‚£è¡Œåˆ—ã‚’ä½¿ç”¨ã—ã¦åº§æ¨™ã‚’å¤‰æ›ã—ã¾ã™ã€‚
  - åº§æ¨™ã¯æ­£è¦åŒ–ãŒå¿…è¦ã§ã™ã€‚

# Apple Metalãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®åŸºæœ¬æ¦‚å¿µ

- **Metalã¨ã¯**:
  - Metalã¯ã€AppleãŒæä¾›ã™ã‚‹ä½ãƒ¬ãƒ™ãƒ«ã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãŠã‚ˆã³ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒˆAPIã§ã€iOSã€macOSã€tvOSã§ä½¿ç”¨ã§ãã¾ã™ã€‚
  - é«˜åŠ¹ç‡ãªGPUã‚¢ã‚¯ã‚»ã‚¹ã‚’æä¾›ã—ã€ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚„ãƒ‡ãƒ¼ã‚¿ä¸¦åˆ—è¨ˆç®—ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’å‘ä¸Šã•ã›ã¾ã™ã€‚
  - DirectXã‚„OpenGLã®ã‚ˆã†ãªä»–ã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹APIã«æ¯”ã¹ã¦ã€ã‚ˆã‚Šç›´æ¥çš„ã‹ã¤åŠ¹ç‡çš„ãªãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢åˆ¶å¾¡ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚

- **ãƒ†ã‚¯ã‚¹ãƒãƒ£**:
  - ç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’GPUãƒ¡ãƒ¢ãƒªä¸Šã«æ ¼ç´ã—ã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚
  - ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™ï¼ˆUVåº§æ¨™ï¼‰ã‚’ä½¿ç”¨ã—ã¦ç‰¹å®šã®ä½ç½®ã‚’å‚ç…§ã—ã¾ã™ã€‚

- **ã‚³ãƒãƒ³ãƒ‰ãƒãƒƒãƒ•ã‚¡**:
  - GPUã«é€ä¿¡ã™ã‚‹ä¸€é€£ã®ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚
  - è¤‡æ•°ã®ã‚³ãƒãƒ³ãƒ‰ã‚’ä¸€æ‹¬ã—ã¦é€ä¿¡ã—ã€åŠ¹ç‡çš„ãªå‡¦ç†ã‚’å®Ÿç¾ã—ã¾ã™ã€‚
  - åŒæœŸã¨ä¾å­˜é–¢ä¿‚ã®ç®¡ç†ã€éåŒæœŸå®Ÿè¡Œã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚

- **ã‚³ãƒãƒ³ãƒ‰ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼**:
  - ã‚³ãƒãƒ³ãƒ‰ãƒãƒƒãƒ•ã‚¡ã«ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ãŸã‚ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚
  - ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚³ãƒãƒ³ãƒ‰ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒˆã‚³ãƒãƒ³ãƒ‰ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼ã€ãƒ–ãƒ©ã‚¹ã‚¿ãƒ¼ã‚³ãƒãƒ³ãƒ‰ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼ãŒã‚ã‚Šã¾ã™ã€‚

- **ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆ**:
  - GPUã«ãŠã‘ã‚‹æç”»ã‚„è¨ˆç®—ã®è¨­å®šã‚’ã‚«ãƒ—ã‚»ãƒ«åŒ–ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚
  - ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã¨ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒˆãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆãŒã‚ã‚Šã¾ã™ã€‚
  - ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®è¨­å®šã€ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã€ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã€æ·±åº¦ãƒ»ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ†ã‚¹ãƒˆã®è¨­å®šãªã©ãŒå«ã¾ã‚Œã¾ã™ã€‚

# ãƒ›ãƒ¢ã‚°ãƒ©ãƒ•ã‚£å¤‰æ›ã®å®Ÿè£…

## ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚³ãƒ¼ãƒ‰
  - å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’èª­ã¿è¾¼ã¿ã€ãƒ›ãƒ¢ã‚°ãƒ©ãƒ•ã‚£è¡Œåˆ—ã‚’ä½¿ç”¨ã—ã¦åº§æ¨™ã‚’å¤‰æ›ã—ã€å‡ºåŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£ã«æ›¸ãè¾¼ã¿ã¾ã™ã€‚
  - ãƒãƒƒã‚¯ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä½¿ç”¨ã—ã¦ã€ç”»ç´ æŠœã‘ã‚’é˜²ããŸã‚ã«é€†ãƒ›ãƒ¢ã‚°ãƒ©ãƒ•ã‚£è¡Œåˆ—ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

```metal
#include <metal_stdlib>
using namespace metal;

kernel void homographyTransform(
    texture2d<float, access::read> inputTexture [[texture(0)]],   // å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£
    texture2d<float, access::write> outputTexture [[texture(1)]], // å‡ºåŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£
    constant float4x4 &inverseHomographyMatrix [[buffer(0)]],     // é€†ãƒ›ãƒ¢ã‚°ãƒ©ãƒ•ã‚£è¡Œåˆ—
    uint2 gid [[thread_position_in_grid]])                        // ã‚¹ãƒ¬ãƒƒãƒ‰ã®ä½ç½®
{
    if (gid.x >= outputTexture.get_width() || gid.y >= outputTexture.get_height()) {
        return;
    }

    float2 outputCoord = float2(gid) / float2(outputTexture.get_width(), outputTexture.get_height());

    float3 inputCoord = float3(outputCoord, 1.0) * inverseHomographyMatrix;
    inputCoord /= inputCoord.z;

    float2 textureCoord = float2(inputCoord.x, inputCoord.y);

    if (textureCoord.x >= 0.0 && textureCoord.x <= 1.0 && textureCoord.y >= 0.0 && textureCoord.y <= 1.0) {
        outputTexture.write(inputTexture.sample(sampler(mip_filter::linear), textureCoord), gid);
    } else {
        outputTexture.write(float4(0.0), gid);
    }
}
```

## ãƒ›ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰
  - é€†ãƒ›ãƒ¢ã‚°ãƒ©ãƒ•ã‚£è¡Œåˆ—ã‚’è¨ˆç®—ã—ã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã«æ¸¡ã—ã¾ã™ã€‚
  - ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½œæˆã—ã€ã‚³ãƒãƒ³ãƒ‰ãƒãƒƒãƒ•ã‚¡ã¨ã‚³ãƒãƒ³ãƒ‰ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼ã‚’ä½¿ç”¨ã—ã¦å‡¦ç†ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

```swift
import Metal
import MetalKit

class HomographyRenderer {
    var device: MTLDevice!
    var commandQueue: MTLCommandQueue!
    var pipelineState: MTLComputePipelineState!

    init() {
        device = MTLCreateSystemDefaultDevice()
        commandQueue = device.makeCommandQueue()
        
        let library = device.makeDefaultLibrary()
        let kernelFunction = library?.makeFunction(name: "homographyTransform")
        pipelineState = try! device.makeComputePipelineState(function: kernelFunction!)
    }

    func applyHomography(inputImage: UIImage, homographyMatrix: float4x4) async -> UIImage? {
        guard let cgImage = inputImage.cgImage else { return nil }
        
        let inverseMatrix = homographyMatrix.inverse
        
        let textureLoader = MTKTextureLoader(device: device)
        let inputTexture = try! textureLoader.newTexture(cgImage: cgImage, options: nil)
        
        let inputWidth = inputTexture.width
        let inputHeight = inputTexture.height
        
        let boundingBox = calculateBoundingBox(homographyMatrix: inverseMatrix, width: inputWidth, height: inputHeight)
        
        let outputWidth = Int(boundingBox.max.x - boundingBox.min.x)
        let outputHeight = Int(boundingBox.max.y - boundingBox.min.y)
        
        let descriptor = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .rgba8Unorm, width: outputWidth, height: outputHeight, mipmapped: false)
        descriptor.usage = [.shaderRead, .shaderWrite]
        let outputTexture = device.makeTexture(descriptor: descriptor)!
        
        let commandBuffer = commandQueue.makeCommandBuffer()!
        let commandEncoder = commandBuffer.makeComputeCommandEncoder()!
        commandEncoder.setComputePipelineState(pipelineState)
        commandEncoder.setTexture(inputTexture, index: 0)
        commandEncoder.setTexture(outputTexture, index: 1)
        
        var inverseMatrixCopy = inverseMatrix
        let matrixBuffer = device.makeBuffer(bytes: &inverseMatrixCopy, length: MemoryLayout<float4x4>.size, options: .storageModeShared)
        commandEncoder.setBuffer(matrixBuffer, offset: 0, index: 0)
        
        let threadGroupCount = MTLSize(width: 16, height: 16, depth: 1)
        let threadGroups = MTLSize(width: (outputTexture.width + 15) / 16, height: (outputTexture.height + 15) / 16, depth: 1)
        commandEncoder.dispatchThreadgroups(threadGroups, threadsPerThreadgroup: threadGroupCount)
        commandEncoder.endEncoding()
        
        commandBuffer.commit()
        await withCheckedContinuation { continuation in
            commandBuffer.addCompletedHandler { _ in
                continuation.resume()
            }
        }
        
        let outputCGImage = outputTexture.toImage()
        return UIImage(cgImage: outputCGImage)
    }
}

extension MTLTexture {
    func toImage() -> CGImage {
        let width = self.width
        let height = self.height
        let rowBytes = width * 4
        
        let colorSpace = CGColorSpaceCreateDeviceRGB()
        let bitmapInfo = CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedLast.rawValue)
        let context = CGContext(data: nil, width: width, height: height, bitsPerComponent: 8, bytesPerRow: rowBytes, space: colorSpace, bitmapInfo: bitmapInfo.rawValue)!
        
        let pixels = UnsafeMutableRawPointer.allocate(byteCount: rowBytes * height, alignment: MemoryLayout<UInt8>.alignment)
        self.getBytes(pixels, bytesPerRow: rowBytes, from: MTLRegionMake2D(0, 0, width, height), mipmapLevel: 0)
        
        context.data!.copyMemory(from: pixels, byteCount: rowBytes * height)
        let cgImage = context.makeImage()!
        pixels.deallocate()
        
        return cgImage
    }
}

func transformedPoint(point: SIMD3<Float>, matrix: float4x4) -> SIMD2<Float> {
    let transformedPoint = matrix * point
    return SIMD2<Float>(transformedPoint.x / transformedPoint.z, transformedPoint.y / transformedPoint.z)
}

func calculateBoundingBox(homographyMatrix: float4x4, width: Int, height: Int) -> (min: SIMD2<Float>, max: SIMD2<Float>) {
    let corners: [SIMD3<Float>] = [
        SIMD3<Float>(0, 0, 1),
        SIMD3<Float>(Float(width), 0, 1),
        SIMD3<Float>(0, Float(height), 1),
        SIMD3<Float>(Float(width), Float(height), 1)
    ]

    var minX = Float.greatestFiniteMagnitude
    var minY = Float.greatestFiniteMagnitude
    var maxX = -Float.greatestFiniteMagnitude
    var maxY = -Float.greatestFiniteMagnitude

    for corner in corners {
        let transformed = transformedPoint(point: corner, matrix: homographyMatrix)
        minX = min(minX, transformed.x)
        minY = min(minY, transformed.y)
        maxX = max(maxX, transformed.x)
        maxY = max(maxY, transformed.y)
    }

    return (min: SIMD2<Float>(minX, minY), max: SIMD2<Float>(maxX, maxY))
}
```

# ç”»ç´ æŠœã‘ã®å¯¾ç­–

- **ãƒãƒƒã‚¯ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆé€†å¤‰æ›ï¼‰**:
  - å¤‰æ›å¾Œã®ç”»åƒã‹ã‚‰å…ƒã®ç”»åƒã«å¯¾å¿œã™ã‚‹ãƒ”ã‚¯ã‚»ãƒ«ã‚’è¦‹ã¤ã‘ã‚‹æ–¹æ³•ã€‚
  - é€†ãƒ›ãƒ¢ã‚°ãƒ©ãƒ•ã‚£è¡Œåˆ—ã‚’ä½¿ç”¨ã—ã¦å…ƒã®åº§æ¨™ã‚’è¨ˆç®—ã—ã€è£œé–“ã«ã‚ˆã‚‹ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã‚’è¡Œã„ã¾ã™ã€‚
  - ã“ã‚Œã«ã‚ˆã‚Šã€å¤‰æ›å¾Œã®ç”»åƒã®ç”»ç´ æŠœã‘ã‚’é˜²ãã¾ã™ã€‚

# ã¾ã¨ã‚

æœ¬è¨˜äº‹ã§ã¯ã€Appleã®Metalãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’ä½¿ç”¨ã—ãŸãƒ›ãƒ¢ã‚°ãƒ©ãƒ•ã‚£å¤‰æ›ã®åŸºæœ¬æ¦‚å¿µã€å®Ÿè£…æ–¹æ³•ã€ãŠã‚ˆã³ç”»ç´ æŠœã‘å¯¾ç­–ã«ã¤ã„ã¦è©³ç´°ã«èª¬æ˜ã—ã¾ã—ãŸã€‚ãƒ›ãƒ¢ã‚°ãƒ©ãƒ•ã‚£å¤‰æ›ã¯ã€ç”»åƒã®å°„å½±å¤‰æ›ã‚’è¡Œã†å¼·åŠ›ãªæ‰‹æ³•ã§ã‚ã‚Šã€æ­£ã—ã„å®Ÿè£…ã¨è£œé–“æŠ€è¡“ã‚’ç”¨ã„ã‚‹ã“ã¨ã§ã€é«˜å“è³ªãªç”»åƒå¤‰æ›ã‚’å®Ÿç¾ã§ãã¾ã™ã€‚